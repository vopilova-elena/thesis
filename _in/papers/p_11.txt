© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru



  Об аппроксимации некоторых трансцендентных функций в
                компьютерной арифметике
                                                 Гаврилов К. В.

           Новосибирский государственный технический университет, Новосибирск, Россия

    Аннотация. В статье предложены алгоритмы быстрого вычисления некоторых трансцендентных функций из числа
элементарных (синус, косинус, тангенс, логарифм и показательная функция), приведены соответствующие программные
коды, обеспечивающие одинарную точность вычислений (стандарта IEEE 754), с использованием языка ассемблера для x86-
совместимых компьютеров. Построение аппроксимаций основано на разложении функций в ряд Чебышёва (разложение по
многочленам Чебышёва первого рода). Однако прямое применение данной техники не всегда приводит к достаточно
эффективным решениям. Причины могут крыться как в недостаточной скорости сходимости ряда, так и в необходимости
выполнения дополнительных вычислений для приведения аргумента функции в промежуток аппроксимации. В связи с этим
в статье иллюстрируются некоторые приемы повышения эффективности вычислительных алгоритмов. Дополнительным
средством повышения производительности служит использование при написании кода расширений AVX и FMA набора
инструкций x86. Для оценки эффективности полученного кода проведено сравнение по времени работы предложенных
функций с функциями, реализованными на базе команд математического сопроцессора, а также стандартными функциями
языка C++ в среде Visual Studio 2013.
    Ключевые слова: аппроксимация функций, полиномы Чебышёва, компьютерная арифметика, схема Горнера, язык
ассемблера, математический сопроцессор.


        ВВЕДЕНИЕ                                             ускоренные версии таких функций, включая и
                                                             стандартные          библиотеки            для           языков
   В    современных      компьютерах     на    базе          программирования.
архитектуры x86 аппаратно поддерживаются                          Одним из наиболее эффективных методов
одинарная, двойная и расширенная точности                    построения аппроксимаций функций является
вычислений с плавающей точкой. Данные форматы                разложение функций в ряд по многочленам
описаны в стандарте IEEE 754 и занимают в памяти             Чебышёва первого рода [4, 5]
соответственно 4, 8 и 10 байт [1]. Исторически
                                                                   Tn (t ) = (t + t 2 − 1) n + (t − t 2 − 1) n  =
                                                                            1
вычисления с плавающей точкой производились                                 2                                     
средствами математического сопроцессора (FPU),
функции которого сейчас интегрированы в                             = cos(n arccos t ) , −1  t  1 , n = 0, 1, 2, ... .
центральный процессор [2]. Хотя математический                   Данные многочлены являются ортогональными
сопроцессор поддерживает все перечисленные                   в весовом L 2 -пространстве с весом
выше форматы данных, внутренние вычисления в
нем    производятся    всегда    с    расширенной                                  1 1− t2 .
точностью. Данное обстоятельство, а также иногда                  Они также обладают свойством наименьшего
недостаточно быстрая аппаратная реализация                   уклонения от нуля на отрезке [−1; 1] , благодаря
алгоритмов, заставляет разработчиков создавать               чему аппроксимация на их основе по точности
более производительные алгоритмы для нужд тех                лишь       незначительно    уступает  наилучшему
приложений, где не важны компактность кода и                 равномерному приближению (среди многочленов
высокая точность вычислений, но важна скорость.              той же степени), однако коэффициенты ряда
Задача    создания    быстрых      вычислительных            Чебышёва        вычисляются    проще,   чем  для
алгоритмов с одинарной и двойной точностью                   наилучшего равномерного приближения [6].
стала особенно актуальной после появления таких                     Запишем ряд Чебышёва для некоторой
расширений набора инструкций, как 3DNow!                     достаточно гладкой на отрезке [−1; 1] функции
(фирмы AMD), SSE, затем SSE2 (фирмы Intel) и
                                                              f (t ) :
дальнейших, с помощью которых можно
производить расчеты с одинарной и двойной                                                    
                                                                                        c
точностью       быстрее,      чем       средствами                              f (t ) = 0 +  ciTi (t ) .
                                                                                         2 i =1
математического сопроцессора. Кроме того, данные
расширения     (их   также     называют      SIMD-              Умножим это равенство скалярно на Tn (t ) . При
расширения)          позволяют            повысить           этом все слагаемые правой части обратятся в 0,
производительность кода за счет векторизации                 кроме слагаемого с номером i = n , которое будет
вычислений [3]. Между тем большинство                        равно cn π 2 . Отсюда получаем выражение для
трансцендентных математических функций не                    коэффициентов разложения
были аппаратно реализованы в SIMD-расширениях,
в связи с чем появились и продолжают появляться
библиотеки       подпрограмм,        реализующие
   © Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                                            51
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru
                              1                                        Заметим, что в обоих случаях можно было бы
                          2        f (t )Tn (t )
                   cn =
                          π                       dt =            потребовать, чтобы ошибка составляла половину
                              −1     1− t2                         младшего разряда, как бывает при правильном
               π                                                   округлении чисел. Нетрудно видеть, что это не
             2
             π
         =      f (cos u ) cos(nu )du , n = 0, 1, 2, ... .         влияет на результат. В общем случае для мантиссы
               0                                                   размером k двоичных разрядов эквивалентное
    Поскольку      | Tn (t ) | 1 , для достижения                 среднее количество значащих десятичных цифр
                                                                   определяется по формуле
требуемой точности отбрасываем члены ряда,                                        m  0,5 + (k − 0,5) lg 2 .
начиная с того, у которого величина c n по модулю
оказалась меньше допустимой погрешности.
    Завершающим            шагом      в  получении                       1. АППРОКСИМАЦИЯ ФУНКЦИЙ
аппроксимации является приведение подобных в
частичной сумме ряда Чебышёва. В результате                           1. Синус. Рассмотрим задачу вычисления
получаем аппроксимирующий многочлен                                функции sin x . Учитывая периодичность функции,
                                                                   удобно аппроксимировать один ее полупериод. Это
               f (t )  b0 + b1t + ... + bn −1t n −1 ,             достигается приведением аргумента в диапазон
который имеет ту же степень, что и номер                           x  [− π 2 ; π 2] и делением на π 2 , т.е. полагаем
последнего выписанного члена ряда. Если функция                                         t = ( x − kπ) 2 π ,
 f (t ) четная, ее разложение будет содержать только
                                                                   где k  x π – округленная до целых величина x π .
четные степени аргумента; в этом случае для
удобства нумерацию коэффициентов будем вести                       Также удобно понизить степень ряда, разделив
только по четным степеням.                                         функцию на t. Таким образом, будем строить
       В рамках статьи изложенные выкладки не                      аппроксимацию функции
будут подробно расписываться, будут только                                               1   πt
                                                                                 f (t ) = sin , t  [−1; 1] .
приводиться готовые коэффициенты bi (или                                                 t   2
функции от них) в программном коде. Для их                            В силу ее четности ряд будет содержать только
вычислений использовались системы Wolfram                          четные степени (всего понадобится 5 членов).
Alpha [7], MathCad [8] и онлайн-калькулятор                        Результат будет вычисляться по формуле
многочленов Чебышёва [9]. В программной                                    sin x = (−1) k sin( x − kπ) = (−1) k t f (t ) .
реализации                 функций                    вычисления       Стоит заметить, что при возрастании по
аппроксимирующего полинома производятся по                         модулю значения x будет происходить снижение
схеме Горнера [10].                                                точности функции, поскольку для аргумента
     Далее в статье речь будет идти, главным                       тригонометрических функций важно не количество
образом, о числах с одинарной точностью.                           значащих цифр, а количество знаков дробной
Остановимся подробнее на том, какая это точность.
                                                                   части. При x  2 23 число не будет иметь дробной
Данный формат служит для записи чисел в
двоичном экспоненциальном представлении (за                        части, и тогда возвращаемые значения функции
исключением нуля и других специальных                              становятся похожими на случайные числа. К
значений), и содержит знаковый бит, 8 битов                        сожалению, в рамках фиксированного формата
порядка и 23 бита мантиссы. Фактически мантисса                    числа с этой ситуацией практически невозможно
имеет 24 бита, поскольку старший ее бит                            бороться, и мы оставим это свойство алгоритма как
присутствует неявно – в нормализованном числе он                   есть. Код функции показан на Рис. 1.
всегда установлен, и его нет необходимости                             Между тем в алгоритме обработана ситуация,
хранить явно. Таким образом, ошибка величиной в                    когда | x | π  231 (приблизительно) или x не число.
единицу младшего разряда мантиссы дает                             В этом случае функция возвращает без изменения
относительную погрешность δ такую, что                             ее аргумент. Частично проблема потери точности
2 −24  δ  2 −23 в зависимости от числа. В среднем                при больших значениях | x | может быть решена за
можно считать δ  2 −23,5 . Теперь рассмотрим                      счет более точного вычисления t (например, с
десятичное число, содержащее m значащих цифр.                      двойной точностью), правда, это не спасет от
Аналогично находим, что ошибка в единицу                           влияния ошибок округления исходных данных,
младшего     разряда     дает    относительную                     представленных все равно с одинарной точностью.
                                                                   Сказанное относится ко всем рассмотренным
погрешность      около       10 0,5 − m .   Приравнивая            тригонометрическим функциям.
относительные погрешности, находим                                     Для сокращения количества вычислений в
              m  0,5 + 23,5 lg 2  7,574 .                        качестве          аргумента      аппроксимирующего
Т.е. число с одинарной точностью эквивалентно по                   многочлена берется не t, а t 2 , поскольку
относительной погрешности числу, содержащему в                     вычисляется величина x π − k  [−0,5; 0,5] , в то
среднем 7,6 значащих десятичных цифр. Обычно
говорят о точности в 7-8 значащих цифр.                            время      как      аппроксимирующий       многочлен
                                                                   определен на отрезке [−1; 1] . Поэтому все

    © Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                                          52
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru

коэффициенты bi заранее умножены на 2 2i +1 .            аппроксимации с двойной точностью требуется
                                                         вычисление 9 коэффициентов.
Заметим также, что для построения аналогичной




Рис. 1. Листинг функции для вычисления синуса

   2. Косинус. Рассмотрим задачу вычисления              Здесь k  2x π – округленная до целых величина
функции cos x . Как и в предыдущем случае,               2x π . На первый взгляд было бы удобно
положим
                                                         разложить в ряд Чебышёва функцию
                     t = ( x − kπ) 2 π ,
                                                                                       1 πt
где k  x π – округленная до целых величина x π .                           f (t ) = tg .
                                                                                       t   4
Строится аппроксимация функции                               Однако    расчеты         показывают,  что  для
                             πt                          достижения одинарной точности в этом случае
              f (t ) = cos , t  [−1; 1] .
                              2                          потребовалось бы вычислить 7 коэффициентов. Но
В силу ее четности ряд будет содержать только            если взять обратную величину от этой функции,
четные степени (всего понадобится 6 членов).             т.е. положить
Результат будет вычисляться по формуле                                                     πt
                                                                            f (t ) = t ctg ,
        cos x = (−1) k cos( x − kπ) = (−1) k f (t ) .                                      4
В    остальном      для      данной      аппроксимации   тогда достаточно будет вычислить лишь 5
справедливо все сказанное в отношении функции            коэффициентов. Таким образом, более удачный
синус. Код функции показан на Рис. 2.                    выбор     функции        f (t )   позволил ускорить
                                                         сходимость ряда. Результат вычисляется по
   3. Тангенс. Рассмотрим задачу вычисления              формуле
функции    tg x . Как и в случае других                                                                  k
                                                                  tg x = (−1) k [tg( x − k π 2)][( −1)       ]
                                                                                                                 =
тригонометрических        функций,          в качестве
промежутка аппроксимации выберем полупериод                             − f (t ) t , k нечетное ;
                                                                       =
функции x  [− π 4 ; π 4] . Тогда                                        t f (t ) , k четное .
             t = 4 x π − 2k , t  [−1; 1] .
   © Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                                         53
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru

Правда, при этом для четных k вместо одной              экономия у нас составляет 2 итерации, т.е. более
операции умножения потребуется более медленная          существенная. Зато для нечетных k деление
операция деления. Временны́е потери от такой            требуется в любом случае, и в результате мы
замены приблизительно соответствуют одной               получаем более заметный выигрыш. Код функции
итерации цикла вычисления полинома, однако              показан на Рис. 3.




Рис. 2. Листинг функции для вычисления косинуса

   Для уменьшения количества операций в                 через двоичный логарифм умножением на
программе        в        качестве          аргумента   соответствующую константу.
аппроксимирующего многочлена вместо t берется                Процедура    деления    или     умножения
величина t 2 = 2 x π − k  [−0,5; 0,5] , поэтому все    вещественных чисел в компьютерных форматах на
                                                        степень двойки очень простая и не приводит к
коэффициенты bi заранее умножены на 2 2i −1 .           потере точности – она сводится к изменению
Константы b0 2 и 2 π совпали, поэтому для них в         порядка числа. По этой причине промежуток
программе используется одна константа. Функция          аппроксимации двоичного логарифма наиболее
может быть легко переделана под вычисление              экономично выбирать так, чтобы левая его граница
котангенса: для этого достаточно поменять               была в 2 раза меньше правой. Так, данную
местами делимое и делитель в операции деления.          функцию нередко аппроксимируют на отрезке
Для построения аналогичной аппроксимации с              [1; 2] .  Но   здесь   есть   важный      нюанс.
двойной точностью потребовалось бы вычислить            Аппроксимирующий многочлен обычно имеет
10 коэффициентов разложения.                            свободный член, содержащий фиксированное
    4. Логарифм. Рассмотрим задачу вычисления           количество знаков после запятой. Поэтому
функции       ln x . Поскольку    в   компьютере        полученное приближенное значение логарифма
используется двоичное представление данных,             будет содержать в лучшем случае столько же
удобно производить расчет двоичного логарифма           верных знаков после запятой. Но при x  1
lb x , а логарифмы по другим основаниям выражать        логарифм становится близким к 0, и при
                                                        неизменном количестве знаков после запятой
   © Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                         54
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru

количество верных значащих цифр может                   отрезка отличаются в 2 раза, как и требуется. В
существенно уменьшаться, т.е. падает точность.          этом случае полагаем
Для борьбы с этим явлением используется                                  f (t ) = lb( t 3 + 1) t , t = 3 y ,
аппроксимация функции lb( y + 1) в окрестности          а результат получается по формуле
точки y = 0 . Далее мы будем строить такую                              lb x = lb( y + 1) = t f (t ) + k ,
аппроксимацию,         поэтому         найденные        где k – число, на которое понадобилось уменьшить
коэффициенты аппроксимирующего многочлена               порядок величины x, чтобы привести ее в диапазон
можно использовать, в том числе, и для реализации       [ 2 3 ; 4 3] . Здесь мы видим два недостатка. Во-
функции lb( y + 1) .                                    первых, для приведения числа в указанный
    Перейдем к построению аппроксимации. С              диапазон нужно хранить еще одну константу 4 3 и
учетом сказанного представляется разумным               сравнивать с ней число. Во-вторых, для достижения
аппроксимировать функцию lb( y + 1) на отрезке          одинарной точности требуется 10 членов
y  [− 1 3 ; 1 3] . Тогда соответствующий отрезок для   разложения, т.е. ряд Чебышёва для данной функции
функции lb x имеет вид x  [2 3 ; 4 3] , т.е. границы    f (t ) сходится слишком медленно.




Рис. 3. Листинг функции для вычисления тангенса

Более высокой скоростью сходимости обладает ряд         которому соответствует диапазон x  [ 2 2 ; 2 ] .
Чебышёва для функции
                                                        Такое значение a целесообразно использовать для
                1 a+t       ay    x −1
        f (t ) = lb   , t=     =a      ,                вычислений с двойной или более высокой
                t a−t      y+2    x +1                  точностью, когда эффект от уменьшения
где a  1 – некоторая константа, t  [−1; 1] .          количества членов ряда перевешивает расходы на
Наиболее     экономичный       выбор:     a = 3+ 8 ,    операцию сравнения числа с константой 2 . Для
                                                        вычислений с одинарной точностью требуется 4
   © Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                             55
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru

члена ряда,    и, оказывается, что применение                   составляет труда: достаточно проверить его второй
значения a = 3 + 8 не уменьшает необходимое                     по убыванию старшинства бит мантиссы. Таким
                                                                образом, остановимся на последнем варианте.
количество членов разложения по сравнению с
                                                                Конечный результат получается по формуле
выбором a = 5 , которому соответствует диапазон
                                                                                   ln x = (t f (t ) + k ) ln 2 ,
 y  [− 1 3 ; 1 2] . Этот   диапазон      несколько
                                                                где k – число, на которое понадобилось уменьшить
избыточен: нам достаточно, чтобы y  [− 1 4 ; 1 2] ,
                                                                порядок величины x, чтобы привести ее в диапазон
тогда аргумент функции lb x будет принадлежать                  [0,75; 1,5 ] . Код функции показан на Рис. 4.
отрезку x  [0,75; 1,5] . Но зато сравнение числа,
приведенного в диапазон [1; 2] , со значением 1,5 не




Рис. 4. Листинг функции для вычисления натурального логарифма

    Для уменьшения количества операций в                           5.   Показательная     функция.    Рассмотрим
программе      в      качестве     аргумента                                                    x
                                                                задачу вычисления функции e . Прежде всего,
аппроксимирующего многочлена вместо t берется                   заметим, что в компьютерной арифметике данную
величина t a , поэтому все коэффициенты bi                      функцию следует вычислять через двоичную
заранее умножены на a 2i +1 . Также в программе                 показательную функцию. Данная операция имеет
используется непосредственная работа с порядком                 тот нюанс, что при x  0 теряются значащие
числа, и для ускорения работы исключена                         цифры аргумента: они практически не влияют на
поддержка денормализованных чисел (такие числа                  результат, который лежит вблизи 1. Это может
считаются нулем). В случае вычисления логарифма                 быть проблемой в тех формулах (например, в
                                                                формулах для гиперболических функций), где
с двойной точностью при a = 3 + 8 потребовалось                 прямо или косвенно используется выражение вида
бы 8 членов ряда.
                                                                e x − 1 , которое не удалось бы хорошо вычислить с
   © Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                                   56
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru

помощью функции e x . Поэтому наряду с                         функция аппаратно реализована в математическом
показательной функцией бывает полезно иметь                    сопроцессоре (команда f2xm1).
                                                                   Для       нашей       задачи    достаточно
функцию e x − 1 . Для ее вычисления строится                   аппроксимировать функцию
аппроксимация
                                                                        f (t ) = t (2t 2 − 1) , t = 2( x lb e − k )  [−1; 1] ,
         f (t ) = t (2t − 1) , t = x lb e  [−1; 1] .
                                                               где k  x lb e – округленное до целых значение
Затем по ней вычисляется функция                                x lb e . Результат формируется по формуле
              e x − 1 = 2t − 1 = t f (t ) .                                    e x = 2 k (t f (t ) + 1) .
Функция f (t ) здесь выбрана из соображений                    Для получения одинарной точности достаточно
повышения скорости сходимости ряда Чебышёва.                   взять 4 члена разложения со степенями 0, 1, 2 и 4
Такой выбор оправдан, несмотря на наличие                      (коэффициенты при нечетных степенях, начиная со
сравнительно медленной операции деления.                       степени 3, обращаются в 0). В случае
Отметим, что используемый здесь диапазон                       использования двойной точности потребовалось бы
аппроксимации является избыточным, хотя это и                  7 коэффициентов (при степенях 0, 1, 2, 4, 6, 8 и 10).
полезно для прикладных целей. Так, подобная                    Код функции показан на Рис. 5.




Рис. 5. Листинг функции для вычисления показательной функции



    © Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                                              57
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru

   При реализации алгоритма учитывалось, что            реализующие данные алгоритмы на языке C++ с
константа b1 = −0,5 . Также, поскольку в                использованием вставок на языке ассемблера.
качестве аргумента       аппроксимирующего              Проведены исследования производительности
многочлена вместо t берется величина t 2 ,              предложенных алгоритмов. В результате
                                                        исследования     установлено,    что     все
коэффициенты bi были умножены на 2 i . Как и            предложенные     алгоритмы    демонстрируют
для тригонометрических функций, погрешность             эффективность, превышающую эффективность
вычисления показательной функции несколько              соответствующих стандартных функций C++ и
увеличивается с ростом | x | , поскольку                функций, написанных с использованием команд
                                                        математического сопроцессора.
точность результата здесь тоже зависит от
количества знаков после запятой в исходных                     ЛИТЕРАТУРА
данных.
                                                        [1] Зыков А. Г., Поляков В. И. Арифметические
      2. ОЦЕНКА ПРОИЗВОДИТЕЛЬНОСТИ                           основы ЭВМ. – СПб: Университет ИТМО, 2016.
                                                             – 140 с.
   Для      сравнения      производительности           [2] Гагарина Л. Г., Кононова А. И. Архитектура
различных       алгоритмов      использовался                вычислительных систем и Ассемблер с
компьютер на базе процессора AMD FX-8350,                    приложением        методических    указаний     к
работающий под управлением операционной                      лабораторным работам. Учебное пособие. – М.:
системы Microsoft Windows 7. Тестовая                        СОЛОН-Пресс, 2019. – 368 с.
программа выполняет 10000000 вызовов                    [3] Чередов А. Д., Мальчуков А. Н. Организация
                                                             ЭВМ и систем: Учебное пособие. – Томский
функции, и возвращает время выполнения в
                                                             политехнический университет. – 4-е изд.,
миллисекундах. Компилировалась программа в                   перераб. и доп. – Томск: Изд-во Томского
среде Microsoft Visual Studio 2013 с ключом                  политехнического университета, 2016 – 236 с.
«/o2», предназначенным для повышения                    [4] Тиман А. Ф. Теория приближения функций
производительности. Были рассмотрены 3                       действительного переменного. – М.: Гос. изд-во
варианта функции: «SIMD» – предложенный в                    физ.-мат. лит., 1960. – 624 с.
работе код на базе SIMD-инструкций, «C++» –             [5] Дзядык В. К. Введение в теорию равномерного
встроенная стандартная функция C++, «FPU» –                  приближения функций полиномами. – М.: Наука,
функция на базе команд математического                       1977, 512 с.
                                                        [6] Математика, ее содержание, методы и значение.
сопроцессора. Запуск повторялся несколько раз,
                                                             Под ред. Александрова А. Д., Колмогорова А. Н.,
и типичный полученный результат для серии                    Лаврентьева М. А. – М.: Изд. Академии наук
однородных испытаний заносился в Таблицу 1.                  СССР, 1956; т. 2 – 397 с.
                                                        [7] URL: https://www.wolframalpha.com
                                      Таблица 1         [8] URL: https://www.mathcad.com/ru
 Функция       SIMD        C++         FPU              [9] URL: https://www.kontrolnaya-
   sin          109        234         328                   rabota.ru/s/polinom/chebisheva
   cos          109        234         328              [10] Волков Е. А. Численные методы: Учеб. пособие
                                                             для вузов. – 2-е изд., испр. – М.: Наука, 1987. –
    tg          109        265         468                   248 с.
    ln          109        156         764
   exp           94        125         375                                     Константин         Викторович
                                                                               Гаврилов, к.т.н., доцент каф.
                                                                               Автоматики НГТУ. Имеет 12
       ЗАКЛЮЧЕНИЕ                                                              научных публикаций.
                                                                               E-mail: qot@ngs.ru
   В статье рассмотрены особенности и приемы
построения на компьютере эффективных
аппроксимаций функций синус, косинус,
тангенс, логарифм и показательная функция,
относящихся к трансцендентным функциям.
Описанные подходы могут также применяться               Статья получена 02.09.2020.
для аппроксимации других трансцендентных
функций. Предложены алгоритмы на основе
разложений в ряд Чебышёва, и программы,

   On Approximation of Some Transcendental Functions in Computer
                          Arithmetic
                                         Konstantin V. Gavrilov

                       Novosibirsk State Technical University, Novosibirsk, Russia

© Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                                        58
© Автоматика и программная инженерия. 2020, №3(33) http://www.jurnal.nips.ru

    Abstract: The article offers algorithms for fast calculation of some transcendental functions from the number of
elementary ones (sine, cosine, tangent, logarithm, and exponential function), and corresponding program codes are given that
provide single-precision calculations (IEEE 754 standard) using the Assembly language for x86-compatible computers. The
construction of approximations is based on the expansion of functions in the Chebyshev series (expansion in Chebyshev
polynomials of the first kind). However, direct application of this technique does not always lead to sufficiently effective
solutions. The reasons may lie both in the insufficient rate of convergence of the series, and in the need to perform additional
calculations to bring the function argument into the approximation interval. In this regard, the article illustrates some
techniques for improving the efficiency of computational algorithms. An additional way to improve performance is to use the
x86 instruction set when writing AVX and FMA extensions. To evaluate the efficiency of the resulting code, the proposed
functions were compared with functions implemented by the mathematical coprocessor commands, as well as standard C++
functions in Visual Studio 2013.
    Key words: function approximation, Chebyshev polynomials, computer arithmetic, Gorner scheme, Assembly language,
mathematical coprocessor.

        REFERENCES                                                  [7]  URL: https://www.wolframalpha.com
                                                                    [8]  URL: https://www.mathcad.com/ru
[1]   Zikov A. G., Polyakov V. I. Arifmeticheskie osnovi            [9]  URL: https://www.kontrolnaya-
      EVM. – SPb: Universitet ITMO, 2016. – 140 s.                       rabota.ru/s/polinom/chebisheva
[2]   Gagarina L. G., Kononova A. I. Arkhitektura                   [10] Volkov E. A. Chislenniye metodi: Ucheb. posobiye
      vichislitelnikh sistem i Assembler s prilozheniem                  dlya vuzov. – 2-е izd., ispr. – M.: Nauka, 1987. –
      metodicheskikh ukazaniy k laboratornim rabotam.                    248 s.
      Uchebnoye posobiye. – M.: SOLON-Press, 2019. –
      368 s.
[3]   Cheredov A. D., Malchukov A. N. Organizatsiya                                         Konstantin     V.     Gavrilov,
      EVM i sistem: Uchebnoye posobiye. – Tomskiy                                           Candidate of Technical Sciences,
      politeknicheskiy universitet. – 4-e izd., pererab. i                                  Associate Professor of the
      dop. – Tomsk: Izd-vo Tomskogo politeknicheskogo                                       Department of Automation of
      universiteta, 2016 – 236 s.                                                           NSTU. Author of 12 scientific
[4]   Timan A. F. Teoriya priblizheniya funktsiy                                            publications.
      deystvitelnogo peremennogo. – M.: Gos. izd-vo fiz.-                                   E-mail: qot@ngs.ru
      mat. lit., 1960. – 624 s.
[5]   Dzyadik V. K. Vvedeniye v teoriyu ravnomernogo
      priblizheniya funktsiy polinomami. – M.: Nauka,
      1977, 512 s.
[6]   Matematika, ee soderzhaniye, metodi i znacheniye.
      Pod red. Aleksandrova A. D., Kolmogorova A. N.,               The paper has been received on 02/09/2020.
      Lavrentyeva M. A. – M.: Izd. Akademii nauk SSSR,
      1956; t. 2 – 397 s.




© Automatics & Software Enginery. 2020, N 3 (33) http://jurnal.nips.ru/en                                                          59
